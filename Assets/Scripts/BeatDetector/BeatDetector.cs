// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.IO;
namespace BeatProcessor
{
	public class BeatDetector
	{
		const float BEAT_RTIME = 0.1f;
		const int BOX_SIZE = 100;

		// format: wav - 1
		//         mp3 - 0 not supported yet
		// Modifies the given List<long>, put beats int it
		// Returns the length of music in milisecond.
		public static long outputBeats(string filename, short format, List<long> beats){

			List<short> left = new List<short> ();
			List<short> right = new List<short> ();
			WavHeader header = new WavHeader ();

			if (format == 1) {
				WavReader inWav = new WavReader (filename);
				inWav.readWav ();
				left = inWav.getChannel (true);
				right = inWav.getChannel (false);
				header = inWav.getHeader ();
			} else {
				//TODO: MP3 converting	
			}

			List<short> bass = BeatDetector.bandPassFilter40_80 (left);
			bass = BeatDetector.evelopeDetector (bass, (int) header.sampleRate);
			BeatDetector.AverageBox (bass);
			bass = BeatDetector.differentiate (bass);
			bass = BeatDetector.findMax (bass, (int) header.sampleRate);
			
			List<short> drum = BeatDetector.bandPassFilter200_400 (left);
			drum = BeatDetector.evelopeDetector (drum, (int) header.sampleRate);
			BeatDetector.AverageBox (drum);
			drum = BeatDetector.differentiate (drum);
			drum = BeatDetector.findMax (drum, (int) header.sampleRate);

			List<short> output = BeatDetector.combine (bass, drum);
			output = BeatDetector.findMax (output, (int) header.sampleRate);

			return BeatDetector.outputBeatMap (output, (int) header.sampleRate, beats);
		}

		private static double[] zeroDoubleArray(int n){
			double[] output = new double[n];
			for (int i = 0; i < n; i++) {
				output [i] = 0;
			}
			return output;
		}

		// Sampling Rate: 44100 Hz
		// Low frequency: 40 Hz
		// High frequency: 80 Hz
		// To extract bass from signal
		private static List<short> bandPassFilter40_80(List<short> channel){
			const int NZEROS = 4;
			const int NPOLES = 4;
			const double GAIN = 1.236054865e+05;
			double[] xv = zeroDoubleArray(NZEROS+1);
			double[] yv = zeroDoubleArray(NPOLES+1);
			List<short> result = new List<short> ();
			for (int i = 0; i < channel.Count; i++) {
				xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4]; 
				xv[4] = channel[i] / GAIN;
				yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4]; 
				yv[4] =   (xv[0] + xv[4]) - 2 * xv[2]
				+ ( -0.9919727403 * yv[0]) + (  3.9757567400 * yv[1])
					+ ( -5.9755947418 * yv[2]) + (  3.9918107379 * yv[3]);
				result.Add((short)yv[4]);
			}
			return result;
		}

		// Sampling Rate: 44100 Hz
		// Low frequency: 200 Hz
		// High frequency: 400 Hz
		// To extract drum from signal
		private static List<short> bandPassFilter200_400(List<short> channel){
			const int NZEROS = 4;
			const int NPOLES = 4;
			const double GAIN = 5.023914502e+03;
			double[] xv = zeroDoubleArray(NZEROS+1);
			double[] yv = zeroDoubleArray(NPOLES+1);
			List<short> result = new List<short> ();
			for (int i = 0; i < channel.Count; i++) {
				xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4]; 
				xv[4] = channel[i] / GAIN;
				yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4]; 
				yv[4] =   (xv[0] + xv[4]) - 2 * xv[2]
				+ ( -0.9605029194 * yv[0]) + (  3.8775620449 * yv[1])
					+ ( -5.8735537787 * yv[2]) + (  3.9564920691 * yv[3]);
				result.Add((short)yv[4]);
			}
			return result;
		}

		// Evelope detector
		private static List<short> evelopeDetector(List<short> channel, int sampleRate){
			
			double BeatRelease = Math.Exp (-1.0f / (sampleRate * BEAT_RTIME));
			double PeakEnv = 0.0;
			
			List<short> result = new List<short> ();
			for (int i = 0; i < channel.Count; i++) {
				double EnvIn = Math.Abs ((double)channel [i]);
				if (EnvIn > PeakEnv) {
					PeakEnv = EnvIn;
				} else {
					PeakEnv *= BeatRelease;
					PeakEnv += (1.0 - BeatRelease) * EnvIn;
				}
				result.Add((short)PeakEnv);
			}
			return result;
		}

		// down sampling with a box of size 100 to average the signal
		private static void AverageBox(List<short> channel){
			for (int i = 0; i < channel.Count / BOX_SIZE; i++) {
				int sum = 0;
				for (int j = 0; j < BOX_SIZE; j++) {
					sum += channel [i * BOX_SIZE + j];
				}
				sum /= BOX_SIZE;
				for (int j = 0; j < BOX_SIZE; j++) {
					channel [i * BOX_SIZE + j] = (short)sum;
				}
			}
		}

		// differentiate to find the peak (edge detector)
		private static List<short> differentiate(List<short> channel){
			int max = 0;
			List<short> output = new List<short> ();
			for (int i = 0; i < 200; i++) {
				output.Add (0);
			}
			for (int i = 2; i < channel.Count / BOX_SIZE - 2; i++) {
				int result = (channel [(i - 2) * 100] - 8 * channel [(i - 1) * 100] + 8 * channel [(i + 1) * 100] - channel [(i + 2) * 100]) / 12;
				for (int j = 0; j < 100; j++) {
					if (result > 0) {
						output.Add ((short)(result * 10));
						if (result * 10 > max) {
							max = result * 10;
						}
					} else {
						output.Add (0);
					}
				}
			}
			for (int i = 0; i < output.Count; i++) {
				if (output [i] < max / 4) {
					output [i] = 0;
				}
			}
			return output;
		}

		// find local max for the edge to represent the beat
		private static List<short> findMax (List<short> channel, int sample_rate){
			List<short> result = new List<short> ();
			int boxSize = (int) (0.1 * sample_rate);
			int endBeat = 0;
			bool beatOn = false;
			short max = 0;
			int maxIndex = 0;
			int beatEndIndex = 0;
			for (int i = 0; i < channel.Count; i++) {
				if (channel [i] != 0) {
					endBeat = i + boxSize;
					beatOn = true;
					if (channel [i] > max) {
						max = channel [i];
						maxIndex = i;
					}
				}
				if (i >= endBeat && beatOn) {
					beatOn = false;
					for (int j = beatEndIndex; j < i; j++) {
						result.Add (0);
					}
					result [maxIndex] = max;
					max = 0;
					maxIndex = 0;
					beatEndIndex = i;
				}
			}
			for (int i = beatEndIndex; i < channel.Count; i++) {
				result.Add (0);
			}
			return result;
		}

		// combine the two signals of beats together
		private static List<short> combine(List<short> bass, List<short> drum){
			List<short> result = new List<short> (bass);
			for (int i = 0; i < drum.Count; i++) {
				if (drum [i] > result [i]) {
					result [i] = drum [i];
				}
			}
			return result;
		}

		// output beats in milisec.
		private static long outputBeatMap(List<short> signal, int sampleRate, List<long> result){
			float mili = 1.0f * 1000.0f / sampleRate;
			//StreamWriter writer = new StreamWriter (@"/Users/Bessie/Music/MoeMoeRun.txt");
			for (int i = 0; i < signal.Count; i++) {
				if (signal [i] != 0) {
					long timestamp = (long) (mili * i);
					result.Add(timestamp);
					//writer.WriteLine (timestamp);
				}
			}
			//writer.Close ();
			return (long) (signal.Count * 1000.0f / sampleRate);
		}
	}
}

