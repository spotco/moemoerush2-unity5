// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using System.IO;
using System.Collections.Generic;
using UnityEngine;

namespace BeatProcessor
{
	public struct WavHeader
	{
		public byte[] riffID; // "riff"
		public uint size;  
		public byte[] wavID;  // "WAVE"
		public byte[] fmtID;  // "fmt "
		public uint fmtSize;
		public ushort format;
		public ushort channels;
		public uint sampleRate;
		public uint bytePerSec;
		public ushort blockSize;
		public ushort bit;
		public byte[] dataID; // "data"
		public uint dataSize;
	}

	public class WavReader
	{
		private String fileName; 
		private WavHeader header;
		private List<short> lDataList;
		private List<short> rDataList;
		
		public WavReader(String fileName) {
			this.fileName = fileName;
			this.header = new WavHeader();
			this.lDataList = new List<short>();
			this.rDataList = new List<short>();
		}

		private byte[] bytes;
		public WavReader(byte[] file) {
			bytes = file;
		}

		public bool hasError = false;
		public bool hasRead = false;
		public void readWav() {
			if (hasRead) return;
			hasRead = true;
			BinaryReader reader = null;
			FileStream wavFileStream = null;
			if (fileName != null) {
				wavFileStream = new FileStream(fileName, FileMode.Open, FileAccess.Read);
				reader = new BinaryReader(wavFileStream);

			} else if (bytes != null) {
				reader = new BinaryReader(new MemoryStream(bytes));

			}
			header.riffID = reader.ReadBytes(4);
			header.size = reader.ReadUInt32();
			header.wavID = reader.ReadBytes(4);
			header.fmtID = reader.ReadBytes(4);
			header.fmtSize = reader.ReadUInt32();
			header.format = reader.ReadUInt16();
			header.channels = reader.ReadUInt16();
			header.sampleRate = reader.ReadUInt32();
			header.bytePerSec = reader.ReadUInt32();
			header.blockSize = reader.ReadUInt16();
			header.bit = reader.ReadUInt16();
			header.dataID = reader.ReadBytes(4);
			header.dataSize = reader.ReadUInt32();

			if (System.Text.Encoding.UTF8.GetString(header.riffID) != "RIFF" ||
			    System.Text.Encoding.UTF8.GetString(header.wavID) != "WAVE" ||
			    System.Text.Encoding.UTF8.GetString(header.fmtID) != "fmt " ||
			    System.Text.Encoding.UTF8.GetString(header.dataID) != "data") {

				Debug.LogError("WAV PARSE ERROR");
				hasError = true;
			} else {
				hasError = false;
			}


			for (int i = 0; i < header.dataSize / header.blockSize; i++) {
				try{
					lDataList.Add((short)reader.ReadUInt16());
					rDataList.Add((short)reader.ReadUInt16());
				}catch{
					break;
				}
			}
			
			if (reader != null)
			{
				reader.Close();
			}
			if (wavFileStream != null)
			{
				wavFileStream.Close();
			}
		}

		private float[] GetFloatData()
		{
			List<float> rtv = new List<float>();
			for (int i = 0; i < lDataList.Count; i++) {
				rtv.Add((((float)lDataList[i]) + 32767.0f)/65534.0f);
				rtv.Add((((float)rDataList[i]) + 32767.0f)/65534.0f);
			}
			return rtv.ToArray();
		}

		private AudioClip _cached_clip;
		public AudioClip getAudioClip() {
			if (_cached_clip != null) return _cached_clip;
			AudioClip clip = AudioClip.Create(
				"test",
				Convert.ToInt32(header.dataSize / header.blockSize),
				Convert.ToInt32(header.channels),
				Convert.ToInt32(header.sampleRate),
				false
			);
			_cached_clip = clip;
			clip.SetData(GetFloatData(),0);
			return clip;
		}

		private List<long> _cached_values = null;
		public List<long> getBeatTimings() {
			if (_cached_values != null) return _cached_values;
			_cached_values = new List<long>();
			BeatDetector.outputBeats(this,_cached_values);
			return _cached_values;
		}

		public string info() {
			return string.Format("[format:{0} channels:{1} sampleRate:{2} bytesPerSec:{3} blockSize:{4} dataSize:{5} ({6} samples)]",
				header.format,
				header.channels,
				header.sampleRate,
				header.bytePerSec,
				header.blockSize, 
				header.dataSize, 
				header.dataSize / header.blockSize
			);
		}
		
		public List<short> getChannel(bool left){
			if (left) {
				return new List<short> (lDataList);
			} else {
				return new List<short> (rDataList);
			}
		}
		
		public String getFileName() {
			return this.fileName;
		}
		
		public WavHeader getHeader() {
			return this.header;
		}
	}
}

